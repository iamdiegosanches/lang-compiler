///////////////////////////////////////////////////////////////////////
/// Álvaro Braz Cunha - 21.1.8163                                   ///
/// Diego Sanches Nere dos Santos - 21.1.8003                       ///
///////////////////////////////////////////////////////////////////////
package lang.parser;

import java_cup.runtime.*;
import lang.nodes.*;
import lang.nodes.decl.*;
import lang.nodes.command.*;
import lang.nodes.expr.*;
import lang.nodes.types.*;
import java.util.ArrayList;

class LangParser;
parser code {:
    // Connect this parser to a scanner!
    LangLexer s;
    public LangParser(LangLexer s){ this.s=s; }
    // Get the line
:}

init with {:               :};
scan with {: return s.nextToken(); :};

/* define how to connect to the scanner! */

/*
   Terminals
*/

terminal                    PLUS, MINUS, MULT, DIV, MOD;
terminal                    NOT, AND;
terminal                    LESS_THAN, EQUAL_EQUAL, ASSIGN, NOT_EQUAL;
terminal                    OPEN_PAREN, CLOSE_PAREN;
terminal                    OPEN_BRACE, CLOSE_BRACE;
terminal                    SEMICOLON, PRINT, ITERATE, READ;
terminal                    COMMA, COLON, DOUBLE_COLON;
terminal                    INT_TYPE, FLOAT_TYPE, BOOL_TYPE;
terminal                    IF, ELSE;
terminal                    RETURN;
terminal                    OPEN_BRACKET, CLOSE_BRACKET;
terminal                    GREATER_THAN; 

terminal CHAR_TYPE;
terminal Character CHAR;

terminal NULL;

terminal Integer            INT;
terminal Float              FLOAT;
terminal String             ID;
terminal Boolean            TRUE,FALSE;

/* Non terminals */
non terminal Exp            expr;
non terminal CNode          prog, cmd, cmdList, block;
non terminal FunDef         fun;
non terminal CType          btype;
non terminal LValue         lvalue;
non terminal Bind           param;
non terminal ArrayList<Bind> params;
non terminal ArrayList<Exp>  expList; 
non terminal ArrayList<LValue> lvalueList;
non terminal ArrayList<CType> typeList;
non terminal ArrayList<FunDef> funSeq;

/*
  Precedencia e associatividade dos operadores.
  Lista em ordem dos de menor prioridade para os de maior
  prioridade.
*/

precedence left SEMICOLON;

precedence left AND;
precedence left EQUAL_EQUAL, NOT_EQUAL;
precedence left LESS_THAN;

precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;

precedence right NOT;
precedence left CLOSE_PAREN; 

precedence nonassoc ELSE;
precedence nonassoc GREATER_THAN;

/* The grammar rules */

prog ::= fun:f funSeq:fs                   {: fs.add(0, f); RESULT = new Program(fleft, fright, fs); :}
       ;


funSeq ::= fun:f funSeq:fs                 {: fs.add(0, f); RESULT = fs; :}
         | /* vazio */                    {: RESULT = new ArrayList<>(); :}
         ;

fun ::= ID:id OPEN_PAREN params:ps CLOSE_PAREN COLON typeList:rets block:body
                                          {: RESULT = new FunDef(idleft, idright, id, ps, rets, body); :}
       | ID:id OPEN_PAREN params:ps CLOSE_PAREN block:body
                                          {: RESULT = new FunDef(idleft, idright, id, ps, new ArrayList<CType>(), body); :}
       ;

params ::= param:p COMMA params:ps        {: ps.add(0, p); RESULT = ps; :}
       | param:p                          {: ArrayList<Bind> list = new ArrayList<>(); list.add(p); RESULT = list; :}
       | /* vazio */                      {: RESULT = new ArrayList<>(); :}
       ;

param ::= ID:id DOUBLE_COLON btype:t
       {: RESULT = new Bind(idleft, idright, t, new Var(idleft, idright, id)); :}
       ;

cmdList ::= cmd:c                         {: RESULT = c; :}
       |    cmdList:cl cmd:c              {: RESULT = new CSeq(clleft, clright, cl, c); :}
       ;

cmd ::= block:b                                                              {: RESULT = b; :}   
       | lvalue:id ASSIGN expr:e SEMICOLON                                   {: RESULT = new CAttr(idleft, idright, id, e); :}
/* | btype:t lvalue:id ASSIGN expr:e SEMICOLON                           {: RESULT = new CDecl(tleft, tright, t, id, e); :} */
       | PRINT:p expr:e SEMICOLON                                            {: RESULT = new Print(pleft, pright, e); :}
       | ITERATE:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c                       {: RESULT = new Loop(ileft, iright, e, c); :}
       | ITERATE:i OPEN_PAREN lvalue:id COLON expr:e CLOSE_PAREN cmd:c       {: RESULT = new IterateWithVar(ileft, iright, id, e, c); :}
       | IF:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c1                           {: RESULT = new If(ileft, iright, e, c1, null); :}
       | IF:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c1 ELSE cmd:c2               {: RESULT = new If(ileft, iright, e, c1, c2); :}
       | READ:r lvalue:lv SEMICOLON                                          {: RESULT = new Read(rleft, rright, lv); :}
       | RETURN:r expList:es SEMICOLON                                       {: RESULT = new Return(rleft, rright, es); :}
       | ID:id OPEN_PAREN expList:args CLOSE_PAREN LESS_THAN lvalueList:lvs GREATER_THAN SEMICOLON 
                                                                             {: RESULT = new FCallCommand(idleft, idright, id, args, lvs); :}
       | ID:id OPEN_PAREN CLOSE_PAREN LESS_THAN lvalueList:lvs GREATER_THAN SEMICOLON 
                                                                             {: RESULT = new FCallCommand(idleft, idright, id, new ArrayList<Exp>(), lvs); :}
       ;

lvalue ::= ID:id                            {: RESULT = new Var(idleft, idright, id);        :}
       ;

lvalueList ::= lvalue:lv COMMA lvalueList:lvs  {: lvs.add(0, lv); RESULT = lvs; :}
             | lvalue:lv                      {: ArrayList<LValue> list = new ArrayList<>(); list.add(lv); RESULT = list; :}
             ;

btype ::= INT_TYPE:t                        {: RESULT = new TyInt(tleft, tright); :}
       |  FLOAT_TYPE:t                      {: RESULT = new TyFloat(tleft, tright); :}
       |  BOOL_TYPE:t                       {: RESULT = new TyBool(tleft, tright); :}
       |  CHAR_TYPE:t                       {: RESULT = new TyChar(tleft, tright); :}
       ;

block ::= OPEN_BRACE cmdList:e CLOSE_BRACE  {: RESULT = e; :}
       | OPEN_BRACE  CLOSE_BRACE            {: RESULT = new CNull(0, 0); :}
       ;

expr ::= expr:e1 AND:t expr:e2            {: RESULT = new And(tleft,tright,e1,e2);         :}
       | expr:e1 PLUS:t expr:e2           {: RESULT = new Plus(tleft,tright,e1,e2);        :}
       | expr:e1 MULT:t expr:e2           {: RESULT = new Times(tleft,tright,e1,e2);       :}
       | expr:e1 MINUS:t expr:e2          {: RESULT = new Sub(tleft,tright,e1,e2);         :}
       | expr:e1 DIV:t expr:e2            {: RESULT = new Div(tleft,tright,e1,e2);         :}
       | expr:e1 LESS_THAN:t expr:e2      {: RESULT = new LessThan(tleft,tright,e1,e2);    :}
       | expr:e1 EQUAL_EQUAL:t expr:e2    {: RESULT = new Equal(tleft,tright,e1,e2);       :}
       | expr:e1 NOT_EQUAL:t expr:e2      {: RESULT = new NotEqual(tleft,tright,e1,e2);    :}
       | expr:e1 MOD:t expr:e2            {: RESULT = new Mod(tleft,tright,e1,e2);         :}
       | NOT:t expr:e                     {: RESULT = new Not(tleft, tright, e);           :}
       | MINUS:t expr:e                   {: RESULT = new UMinus(tleft, tright, e);        :}
       | OPEN_PAREN expr:e CLOSE_PAREN    {: RESULT = e;                                   :}
       | INT:n	                     {: RESULT = new IntLit(nleft,nright,n);          :}
       | FLOAT:n	                     {: RESULT = new FloatLit(nleft,nright,n);        :}
       | TRUE:n	                     {: RESULT = new BoolLit(nleft,nright,n);         :}
       | FALSE:n	                     {: RESULT = new BoolLit(nleft,nright,n);         :}
       | CHAR:c                           {: RESULT = new CharLit(cleft, cright, c);       :}
       | lvalue:id                        {: RESULT = (Exp)id;                             :}
       | NULL:n                           {: RESULT = new NullLit(nleft,nright);           :}
       | ID:id OPEN_PAREN CLOSE_PAREN     {: RESULT = new FCall(idleft, idright, id, new ArrayList<Exp>()); :}
       | ID:id OPEN_PAREN expList:es CLOSE_PAREN                         
                                          {: RESULT = new FCall(idleft, idright, id, es); :}
       | ID:id OPEN_PAREN CLOSE_PAREN OPEN_BRACKET expr:idx CLOSE_BRACKET 
                                          {: RESULT = new FCall(idleft, idright, id, new ArrayList<Exp>(), idx); :}
       | ID:id OPEN_PAREN expList:es CLOSE_PAREN OPEN_BRACKET expr:idx CLOSE_BRACKET 
                                          {: RESULT = new FCall(idleft, idright, id, es, idx); :}
       ;

expList ::= expr:e COMMA expList:es        {: es.add(0, e); RESULT = es; :}
        | expr:e                           {: ArrayList<Exp> list = new ArrayList<>(); list.add(e); RESULT = list; :}
        ;

typeList ::= btype:t COMMA typeList:ts    {: ts.add(0, t); RESULT = ts; :}
           | btype:t                      {: ArrayList<CType> list = new ArrayList<>(); list.add(t); RESULT = list; :}
           ;

/*op ::= AND:
       | LESS_THAN
       | EQUAL_EQUAL
       | NOT_EQUAL
       | PLUS
       | MINUS
       | MULT
       | DIV
       | MOD */