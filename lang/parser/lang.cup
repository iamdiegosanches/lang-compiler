///////////////////////////////////////////////////////////////////////
/// Álvaro Braz Cunha - 21.1.8163                                   ///
/// Diego Sanches Nere dos Santos - 21.1.8003                       ///
///////////////////////////////////////////////////////////////////////
package lang.parser;

import java_cup.runtime.*;
import lang.nodes.*;
import lang.nodes.decl.*;
import lang.nodes.command.*;
import lang.nodes.expr.*;
import lang.nodes.types.*;
import java.util.ArrayList;

class LangParser;
parser code {:
    // Connect this parser to a scanner!
    LangLexer s;
    public LangParser(LangLexer s){ this.s=s; }
    // Get the line
:}

init with {:               :};
scan with {: return s.nextToken(); :};

/* define how to connect to the scanner! */

/*
   Terminals
*/

terminal                    PLUS, MINUS, MULT, DIV, MOD;
terminal                    NOT, AND;
terminal                    LESS_THAN, EQUAL_EQUAL, ASSIGN, NOT_EQUAL;
terminal                    OPEN_PAREN, CLOSE_PAREN;
terminal                    OPEN_BRACE, CLOSE_BRACE;
terminal                    SEMICOLON, PRINT, ITERATE;
terminal                    COMMA, COLON, DOUBLE_COLON;
terminal                    INT_TYPE, FLOAT_TYPE, BOOL_TYPE;
terminal                    IF, ELSE;

terminal CHAR_TYPE;
terminal Character CHAR;

terminal NULL;

terminal Integer            INT;
terminal Float              FLOAT;
terminal String             ID;
terminal Boolean            TRUE,FALSE;

/* Non terminals */
non terminal Exp            expr;
non terminal CNode          prog, cmd, cmdList, fun, block;
non terminal CType          btype;
non terminal Bind           param;
non terminal ArrayList<Bind> params;

/*
  Precedencia e associatividade dos operadores.
  Lista em ordem dos de menor prioridade para os de maior
  prioridade.
*/

precedence left SEMICOLON;
//precedence left OR;
precedence left AND;
precedence left EQUAL_EQUAL, NOT_EQUAL;
precedence left LESS_THAN;

precedence left PLUS, MINUS;
precedence left MULT, MOD, DIV;

precedence right NOT;
precedence left CLOSE_PAREN; 

precedence nonassoc ELSE;

/* The grammar rules */

prog ::= cmdList:xs                           {: RESULT = xs; :}
       ;

/*  Não implementado pois precisa ser reestruturado */
fun ::= ID:id OPEN_PAREN params:ps CLOSE_PAREN COLON btype:ret block:body
       {: RESULT = new FunDef(idleft, idright, id, ps, ret, body); :}
       ;

params ::= param:p COMMA params:ps        {: ps.add(0, p); RESULT = ps; :}
       | param:p                          {: ArrayList<Bind> list = new ArrayList<>(); list.add(p); RESULT = list; :}
       | /* vazio */                      {: RESULT = new ArrayList<>(); :}
       ;

param ::= ID:id DOUBLE_COLON btype:t
       {: RESULT = new Bind(idleft, idright, t, new Var(idleft, idright, id)); :}
       ;

cmdList ::= cmd:c                         {: RESULT = c; :}
       |    cmdList:cl cmd:c              {: RESULT = new CSeq(clleft, clright, cl, c); :}
       ;

cmd ::= block:b                                                       {: RESULT = b; :}   
       | ID:id ASSIGN expr:e SEMICOLON                                {: RESULT = new CAttr(idleft, idright, new Var(idleft, idright, id), e); :}
       | btype:t ID:id ASSIGN expr:e SEMICOLON                        {: RESULT = new CDecl(tleft, tright, t, new Var(idleft, idright, id), e); :}
       | PRINT:p expr:e SEMICOLON                                     {: RESULT = new Print(pleft, pright, e); :}
       | ITERATE:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c                {: RESULT = new Loop(ileft, iright, e, c); :}
       | ITERATE:i OPEN_PAREN ID:id COLON expr:e CLOSE_PAREN cmd:c    {: RESULT = new IterateWithVar(ileft, iright, new Var(idleft, idright, id), e, c); :} /* Não sei pq mas não esta funcionando */
       | IF:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c1                    {: RESULT = new If(ileft, iright, e, c1, null); :}
       | IF:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c1 ELSE cmd:c2        {: RESULT = new If(ileft, iright, e, c1, c2); :}
       ;

btype ::= INT_TYPE:t                        {: RESULT = new TyInt(tleft, tright); :}
       |  FLOAT_TYPE:t                      {: RESULT = new TyFloat(tleft, tright); :}
       |  BOOL_TYPE:t                       {: RESULT = new TyBool(tleft, tright); :}
       |  CHAR_TYPE:t                       {: RESULT = new TyChar(tleft, tright); :}
       ;

block ::= OPEN_BRACE cmdList:e CLOSE_BRACE  {: RESULT = e; :}
       | OPEN_BRACE  CLOSE_BRACE            {: RESULT = new CNull(0, 0); :}
       ;

expr ::= expr:e1 AND:t expr:e2            {: RESULT = new And(tleft,tright,e1,e2);         :}
       | expr:e1 PLUS:t expr:e2           {: RESULT = new Plus(tleft,tright,e1,e2);        :}
       | expr:e1 MULT:t expr:e2           {: RESULT = new Times(tleft,tright,e1,e2);       :}
       | expr:e1 MINUS:t expr:e2          {: RESULT = new Sub(tleft,tright,e1,e2);         :}
       | expr:e1 DIV:t expr:e2            {: RESULT = new Div(tleft,tright,e1,e2);         :}
       | expr:e1 LESS_THAN:t expr:e2      {: RESULT = new LessThan(tleft,tright,e1,e2);    :}
       | expr:e1 EQUAL_EQUAL:t expr:e2    {: RESULT = new Equal(tleft,tright,e1,e2);       :}
       | expr:e1 NOT_EQUAL:t expr:e2      {: RESULT = new NotEqual(tleft,tright,e1,e2);    :}
       | expr:e1 MOD:t expr:e2            {: RESULT = new Mod(tleft,tright,e1,e2);         :}
       | NOT:t expr:e                     {: RESULT = new Not(tleft, tright, e);           :}
       | MINUS:t expr:e                   {: RESULT = new UMinus(tleft, tright, e);        :}
       | OPEN_PAREN expr:e CLOSE_PAREN    {: RESULT = e;                                   :}
       | INT:n	                     {: RESULT = new IntLit(nleft,nright,n);          :}
       | FLOAT:n	                     {: RESULT = new FloatLit(nleft,nright,n);        :}
       | TRUE:n	                     {: RESULT = new BoolLit(nleft,nright,n);         :}
       | FALSE:n	                     {: RESULT = new BoolLit(nleft,nright,n);         :}
       | CHAR:c                           {: RESULT = new CharLit(cleft, cright, c);       :}
       | ID:id                            {: RESULT = new Var(idleft, idright, id);        :}
       | NULL:n                           {: RESULT = new NullLit(nleft,nright);         :}
       ;

/*op ::= AND:
       | LESS_THAN
       | EQUAL_EQUAL
       | NOT_EQUAL
       | PLUS
       | MINUS
       | MULT
       | DIV
       | MOD */