///////////////////////////////////////////////////////////////////////
/// Álvaro Braz Cunha - 21.1.8163                                   ///
/// Diego Sanches Nere dos Santos - 21.1.8003                       ///
///////////////////////////////////////////////////////////////////////
package lang.parser;

import java_cup.runtime.*;
import lang.nodes.*;
import lang.nodes.decl.*;
import lang.nodes.command.*;
import lang.nodes.expr.*;
import lang.nodes.types.*;
import java.util.ArrayList;

class LangParser;
parser code {:
    // Connect this parser to a scanner!
    LangLexer s;
    public LangParser(LangLexer s){ this.s=s; }
    // Get the line
:}

init with {:               :};
scan with {: return s.nextToken(); :};

/* define how to connect to the scanner! */

/*
   Terminals
*/

terminal                    PLUS, MINUS, MULT, DIV, MOD;
terminal                    NOT;
terminal                    LESS_THAN, EQUAL_EQUAL, ASSIGN;
terminal                    OPEN_PAREN, CLOSE_PAREN;
terminal                    OPEN_BRACE, CLOSE_BRACE;
terminal                    SEMICOLON, PRINT, ITERATE;
terminal                    COMMA, COLON, DOUBLE_COLON;
terminal                    INT_TYPE, FLOAT_TYPE, BOOL_TYPE;
terminal                    IF, ELSE;

terminal Integer            INT;
terminal Float              FLOAT;
terminal String             ID;
terminal Boolean            TRUE,FALSE;

/* Non terminals */
non terminal Exp            expr, itcond;
non terminal CNode          prog, cmd, cmdList, fun, block;
non terminal CType          btype;
non terminal Bind           param;
non terminal ArrayList<Bind> params;

/*
  Precedencia e associatividade dos operadores.
  Lista em ordem dos de menor prioridade para os de maior
  prioridade.
*/

precedence left SEMICOLON;
//precedence left OR;
//precedence left AND;
precedence left EQUAL_EQUAL;
precedence left LESS_THAN;

precedence left PLUS, MINUS;
precedence left MULT, MOD, DIV;

precedence right NOT;
// precedence right UMINUS;
precedence left CLOSE_PAREN; 

/* The grammar rules */

prog ::= cmdList:xs                           {: RESULT = xs; :}
       ;

/*  Não implementado pois precisa ser reestruturado */
fun ::= ID:id OPEN_PAREN params:ps CLOSE_PAREN COLON btype:ret block:body
       {: RESULT = new FunDef(idleft, idright, id, ps, ret, body); :}
       ;

params ::= param:p COMMA params:ps        {: ps.add(0, p); RESULT = ps; :}
       | param:p                          {: ArrayList<Bind> list = new ArrayList<>(); list.add(p); RESULT = list; :}
       | /* vazio */                      {: RESULT = new ArrayList<>(); :}
       ;

param ::= ID:id DOUBLE_COLON btype:t
       {: RESULT = new Bind(idleft, idright, t, new Var(idleft, idright, id)); :}
       ;

cmdList ::= cmd:c                         {: RESULT = c; :}
       |    cmdList:cl cmd:c              {: RESULT = new CSeq(clleft, clright, cl, c); :}
       ;

/*   public Loop(int l, int c, Exp e, CNode body){*/
cmd ::=  ID:id ASSIGN expr:e SEMICOLON                          {: RESULT = new CAttr(idleft, idright, new Var(idleft, idright, id), e); :}
       | btype:t ID:id ASSIGN expr:e SEMICOLON                  {: RESULT = new CDecl(tleft, tright, t, new Var(idleft, idright, id), e); :}
       | PRINT:p expr:e SEMICOLON                              {: RESULT = new Print(pleft, pright, e); :}
       | ITERATE:i OPEN_PAREN itcond:e CLOSE_PAREN cmd:c       {: RESULT = new Loop(ileft, iright, e, c); :}
       | IF:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c1             {: RESULT = new If(ileft, iright, e, c1, null); :}
       | IF:i OPEN_PAREN expr:e CLOSE_PAREN cmd:c1 ELSE cmd:c2 {: RESULT = new If(ileft, iright, e, c1, c2); :}
       ;

itcond ::= ID COLON expr:e         {: RESULT = e; :}    /*Falta implementar essa parte na AST*/
       | expr:e                    {: RESULT = e; :}
       ;

btype ::= INT_TYPE:t                        {: RESULT = new TyInt(tleft, tright); :}
       |  FLOAT_TYPE:t                      {: RESULT = new TyFloat(tleft, tright); :}
       |  BOOL_TYPE:t                       {: RESULT = new TyBool(tleft, tright); :}
       ;

block ::= OPEN_BRACE cmdList:e CLOSE_BRACE  {: RESULT = e; :}
       ;

expr ::= expr:e1 PLUS:t expr:e2           {: RESULT = new Plus(tleft,tright,e1,e2);        :}
       | expr:e1 MULT:t expr:e2           {: RESULT = new Times(tleft,tright,e1,e2);       :}
       | expr:e1 MINUS:t expr:e2          {: RESULT = new Sub(tleft,tright,e1,e2);         :}
       | expr:e1 DIV:t expr:e2            {: RESULT = new Div(tleft,tright,e1,e2);         :}
       | expr:e1 LESS_THAN:t expr:e2      {: RESULT = new LessThan(tleft,tright,e1,e2);    :}
       | expr:e1 EQUAL_EQUAL:t expr:e2    {: RESULT = new Equal(tleft,tright,e1,e2);       :}
//       | expr:e1 NOT_EQUAL:t expr:e2      {: RESULT = new NotEqual(tleft,tright,e1,e2);    :}
       | expr:e1 MOD:t expr:e2            {: RESULT = new Mod(tleft,tright,e1,e2);         :}
       | NOT:t expr:e                     {: RESULT = new Not(tleft, tright, e);           :}
       | MINUS:t expr:e                     {: RESULT = new UMinus(tleft, tright, e);      :}
       | OPEN_PAREN expr:e CLOSE_PAREN      {: RESULT = e;                                   :}
       | INT:n	                       {: RESULT = new IntLit(nleft,nright,n);          :}
       | FLOAT:n	                     {: RESULT = new FloatLit(nleft,nright,n);        :}
       | TRUE:n	                     {: RESULT = new BoolLit(nleft,nright,n);         :}
       | FALSE:n	                     {: RESULT = new BoolLit(nleft,nright,n);         :}
       | ID:n                             {: RESULT = new Var(nleft,nright,n);             :}

       ;

/*op ::= AND:
       | LESS_THAN
       | EQUAL_EQUAL
       | NOT_EQUAL
       | PLUS
       | MINUS
       | MULT
       | DIV
       | MOD */