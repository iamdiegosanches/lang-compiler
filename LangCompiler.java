///////////////////////////////////////////////////////////////////////
/// Álvaro Braz Cunha - 21.1.8163                                   ///
/// Diego Sanches Nere dos Santos - 21.1.8003                       ///
///////////////////////////////////////////////////////////////////////

import java.io.FileReader;
import java_cup.runtime.Symbol;
import lang.parser.LangLex; // Correct Lexer class name from your .flex file
import lang.parser.parser;    // Correct Parser class name from your .cup file
import lang.parser.sym;     // Correct Symbol constants class name from JavaCUP

public class LangCompiler {

    public static void main(String[] args) throws Exception {
        if (args.length == 0) {
            System.out.println("Uso: java LangCompiler <opção> <arquivo>");
            System.out.println("Opções:");
            System.out.println("  -lex: Realiza apenas a análise léxica e imprime os tokens.");
            System.out.println("  -syn: Realiza a análise sintática.");
            System.out.println("  -i: Executa a interpretação (ainda não implementado neste exemplo).");
            return; // Exit if no arguments are provided
        }

        String option = args[0];
        String filePath = args[1]; // The file path is always the second argument

        switch (option) {
            case "-lex":
                System.out.println("Realizando análise léxica para: " + filePath);
                // The lexer class generated by JFlex is LangLex, not LangLexer
                LangLex lex = new LangLex(new FileReader(filePath));
                Symbol tk;
                do {
                    tk = lex.next_token();
                    // Using sym.terminalNames to get readable token names
                    System.out.println("(" + tk.left + "," + tk.right + ") " + sym.terminalNames[tk.sym] + (tk.value != null ? " (" + tk.value + ")" : ""));
                } while (tk.sym != sym.EOF); // Use sym.EOF for end of file
                System.out.println("Análise léxica concluída.");
                break;

            case "-i":
                System.out.println("Executado -i para: " + filePath);
                // Interpretation logic would go here
                break;

            case "-syn":
                System.out.println("Realizando análise sintática para: " + filePath);
                // The lexer class generated by JFlex is LangLex
                LangLex lexForParse = new LangLex(new FileReader(filePath));
                // The parser class generated by JavaCUP is parser
                parser p = new parser(lexForParse);
                try {
                    // presult is a local variable, not a field.
                    // The parse() method returns the Symbol associated with the start non-terminal.
                    Symbol presult = p.parse();
                    if (presult != null) {
                        System.out.println("accepted");
                    } else {
                        // This case might not be reached if JavaCUP throws an exception on syntax error
                        System.out.println("rejected (parser returned null)");
                    }
                } catch (Exception e) {
                    System.out.println("rejected");
                    System.err.println("Erro durante a análise sintática: " + e.getMessage());
                    // Optionally print stack trace for debugging
                    // e.printStackTrace();
                }
                break;

            default:
                System.out.println("Opção inválida: " + option);
                System.out.println("Uso: java LangCompiler <opção> <arquivo>");
                System.out.println("Opções:");
                System.out.println("  -lex: Realiza apenas a análise léxica e imprime os tokens.");
                System.out.println("  -syn: Realiza a análise sintática.");
                System.out.println("  -i: Executa a interpretação (ainda não implementado neste exemplo).");
                break;
        }
    }
}
